import React, { useState, useEffect, useRef, useCallback } from 'react';

const GRID_SIZE = 10;
const BUBBLE_SIZE = 50;
const COLORS = ['#ff4757', '#2ed573', '#3742fa', '#ffa502', '#ff6348', '#a55eea', '#26d0ce'];
const MIN_GROUP = 2; // Lower threshold = more addictive

export default function BubbleChainReaction() {
  const [grid, setGrid] = useState([]);
  const [score, setScore] = useState(0);
  const [combo, setCombo] = useState(0);
  const [selectedGroup, setSelectedGroup] = useState([]);
  const [particles, setParticles] = useState([]);
  const [gameState, setGameState] = useState('playing');
  const [showScore, setShowScore] = useState(0);
  const [perfectStreak, setPerfectStreak] = useState(0);
  const [shakingBubbles, setShakingBubbles] = useState(new Set());
  const [lastComboTime, setLastComboTime] = useState(0);

  // Create grid with perfect color distribution for combos
  const createGrid = useCallback(() => {
    const newGrid = [];
    const colorCount = 4; // Keep it simple for more matches
    
    for (let row = 0; row < GRID_SIZE; row++) {
      newGrid[row] = [];
      for (let col = 0; col < GRID_SIZE; col++) {
        // Bias towards creating clusters
        let color = Math.floor(Math.random() * colorCount);
        
        // 30% chance to match adjacent bubble color (creates more clusters)
        if (Math.random() < 0.3) {
          if (col > 0 && newGrid[row][col - 1]) {
            color = newGrid[row][col - 1].color;
          } else if (row > 0 && newGrid[row - 1] && newGrid[row - 1][col]) {
            color = newGrid[row - 1][col].color;
          }
        }
        
        newGrid[row][col] = {
          color,
          id: `${row}-${col}`,
          scale: 1
        };
      }
    }
    return newGrid;
  }, []);

  // Find connected bubbles
  const findConnected = useCallback((grid, row, col, visited = new Set()) => {
    const key = `${row}-${col}`;
    if (visited.has(key) || row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE || !grid[row]?.[col]) {
      return [];
    }

    visited.add(key);
    const color = grid[row][col].color;
    const connected = [{ row, col }];

    [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dr, dc]) => {
      const nr = row + dr, nc = col + dc;
      if (grid[nr]?.[nc]?.color === color) {
        connected.push(...findConnected(grid, nr, nc, visited));
      }
    });

    return connected;
  }, []);

  // Create satisfying particle explosion
  const explode = useCallback((bubbles) => {
    const newParticles = [];
    bubbles.forEach(({ row, col }) => {
      const centerX = col * (BUBBLE_SIZE + 4) + BUBBLE_SIZE / 2;
      const centerY = row * (BUBBLE_SIZE + 4) + BUBBLE_SIZE / 2;
      const color = COLORS[grid[row][col].color];
      
      // More particles for bigger groups
      const particleCount = Math.min(bubbles.length * 2, 20);
      
      for (let i = 0; i < particleCount; i++) {
        const angle = (Math.PI * 2 * i) / particleCount;
        const speed = 3 + Math.random() * 4;
        newParticles.push({
          x: centerX,
          y: centerY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - Math.random() * 2,
          color,
          size: 3 + Math.random() * 4,
          life: 1,
          id: Math.random()
        });
      }
    });
    
    setParticles(prev => [...prev, ...newParticles]);
  }, [grid]);

  // Pop bubbles with juice
  const popBubbles = useCallback((bubbles) => {
    if (bubbles.length < MIN_GROUP) return;

    // Satisfying score calculation
    const baseScore = bubbles.length * bubbles.length * 10; // Quadratic scoring!
    const comboBonus = combo * 100;
    const streakBonus = perfectStreak * 50;
    const sizeBonus = bubbles.length > 6 ? (bubbles.length - 6) * 200 : 0;
    
    const totalScore = baseScore + comboBonus + streakBonus + sizeBonus;
    
    setScore(prev => prev + totalScore);
    setShowScore(totalScore);
    setCombo(prev => prev + 1);
    setLastComboTime(Date.now());
    
    // Perfect bonus for clearing 8+ bubbles
    if (bubbles.length >= 8) {
      setPerfectStreak(prev => prev + 1);
    } else if (bubbles.length < 4) {
      setPerfectStreak(0);
    }

    // Explode!
    explode(bubbles);

    // Remove bubbles
    setGrid(prevGrid => {
      const newGrid = prevGrid.map(row => [...row]);
      bubbles.forEach(({ row, col }) => {
        newGrid[row][col] = null;
      });
      return dropBubbles(newGrid);
    });

    // Hide score display
    setTimeout(() => setShowScore(0), 800);
  }, [combo, perfectStreak, explode]);

  // Drop bubbles down
  const dropBubbles = useCallback((grid) => {
    const newGrid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
    
    for (let col = 0; col < GRID_SIZE; col++) {
      const column = [];
      for (let row = GRID_SIZE - 1; row >= 0; row--) {
        if (grid[row][col]) column.push(grid[row][col]);
      }
      
      for (let i = 0; i < column.length; i++) {
        newGrid[GRID_SIZE - 1 - i][col] = column[i];
      }
    }
    
    return fillEmpty(newGrid);
  }, []);

  // Fill empty spaces with new bubbles (endless mode)
  const fillEmpty = useCallback((grid) => {
    const newGrid = grid.map(row => [...row]);
    
    for (let col = 0; col < GRID_SIZE; col++) {
      for (let row = 0; row < GRID_SIZE; row++) {
        if (!newGrid[row][col]) {
          newGrid[row][col] = {
            color: Math.floor(Math.random() * 4),
            id: `new-${row}-${col}-${Date.now()}`,
            scale: 0 // Start small for animation
          };
        }
      }
    }
    
    return newGrid;
  }, []);

  // Handle bubble click
  const handleClick = useCallback((row, col) => {
    if (!grid[row]?.[col]) return;
    
    const connected = findConnected(grid, row, col);
    
    if (connected.length >= MIN_GROUP) {
      popBubbles(connected);
      setSelectedGroup([]);
    } else {
      // Shake single bubbles
      const key = `${row}-${col}`;
      setShakingBubbles(prev => new Set([...prev, key]));
      setTimeout(() => {
        setShakingBubbles(prev => {
          const next = new Set(prev);
          next.delete(key);
          return next;
        });
      }, 300);
    }
  }, [grid, findConnected, popBubbles]);

  // Handle hover
  const handleHover = useCallback((row, col) => {
    if (!grid[row]?.[col]) return;
    const connected = findConnected(grid, row, col);
    setSelectedGroup(connected.length >= MIN_GROUP ? connected : []);
  }, [grid, findConnected]);

  // Animate particles
  useEffect(() => {
    const animate = () => {
      setParticles(prev => prev.map(p => ({
        ...p,
        x: p.x + p.vx,
        y: p.y + p.vy,
        vy: p.vy + 0.3, // gravity
        life: p.life - 0.015,
        vx: p.vx * 0.99
      })).filter(p => p.life > 0));
    };
    
    const interval = setInterval(animate, 16);
    return () => clearInterval(interval);
  }, []);

  // Animate bubble scales
  useEffect(() => {
    const animate = () => {
      setGrid(prevGrid => prevGrid.map(row => 
        row.map(bubble => {
          if (!bubble) return bubble;
          const targetScale = 1;
          const currentScale = bubble.scale || 0;
          const newScale = currentScale + (targetScale - currentScale) * 0.2;
          return { ...bubble, scale: Math.abs(newScale - targetScale) < 0.01 ? targetScale : newScale };
        })
      ));
    };
    
    const interval = setInterval(animate, 16);
    return () => clearInterval(interval);
  }, []);

  // Reset combo after inactivity
  useEffect(() => {
    const timer = setTimeout(() => {
      if (Date.now() - lastComboTime > 2000) {
        setCombo(0);
      }
    }, 2000);
    return () => clearTimeout(timer);
  }, [lastComboTime]);

  // Initialize
  useEffect(() => {
    if (grid.length === 0) {
      setGrid(createGrid());
    }
  }, [createGrid, grid.length]);

  return (
    <div className="min-h-screen bg-gray-900 flex flex-col items-center justify-center p-4 select-none">
      {/* Minimal score display */}
      <div className="mb-8 text-center">
        <div className="text-4xl font-bold text-white mb-2">
          {score.toLocaleString()}
        </div>
        {combo > 0 && (
          <div className="text-lg text-yellow-400 animate-pulse">
            {combo}x combo
          </div>
        )}
        {perfectStreak > 0 && (
          <div className="text-sm text-purple-400">
            {perfectStreak} perfect streak
          </div>
        )}
      </div>

      {/* Floating score */}
      {showScore > 0 && (
        <div className="fixed top-1/3 left-1/2 transform -translate-x-1/2 pointer-events-none">
          <div className="text-3xl font-bold text-yellow-400 animate-bounce">
            +{showScore.toLocaleString()}
          </div>
        </div>
      )}

      {/* Game grid */}
      <div className="relative">
        <div 
          className="grid gap-1 bg-gray-800 p-4 rounded-2xl shadow-2xl"
          style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)` }}
          onMouseLeave={() => setSelectedGroup([])}
        >
          {grid.map((row, rowIndex) =>
            row.map((bubble, colIndex) => {
              if (!bubble) return null;
              
              const isSelected = selectedGroup.some(b => b.row === rowIndex && b.col === colIndex);
              const isShaking = shakingBubbles.has(`${rowIndex}-${colIndex}`);
              const canPop = selectedGroup.length >= MIN_GROUP;
              
              return (
                <button
                  key={bubble.id}
                  onClick={() => handleClick(rowIndex, colIndex)}
                  onMouseEnter={() => handleHover(rowIndex, colIndex)}
                  className={`
                    rounded-full transition-all duration-150 cursor-pointer
                    ${isSelected && canPop ? 'ring-4 ring-white shadow-lg' : ''}
                    ${isSelected && !canPop ? 'opacity-50' : ''}
                    ${isShaking ? 'animate-pulse' : ''}
                    hover:scale-105 active:scale-95
                  `}
                  style={{
                    width: BUBBLE_SIZE,
                    height: BUBBLE_SIZE,
                    backgroundColor: COLORS[bubble.color],
                    transform: `scale(${bubble.scale || 1}) ${isSelected && canPop ? 'scale(1.1)' : ''}`,
                    boxShadow: isSelected && canPop ? `0 0 25px ${COLORS[bubble.color]}80` : '0 2px 10px rgba(0,0,0,0.3)'
                  }}
                >
                  {isSelected && canPop && selectedGroup.length > MIN_GROUP && (
                    <span className="text-white font-bold text-lg">
                      {selectedGroup.length}
                    </span>
                  )}
                </button>
              );
            })
          )}
        </div>

        {/* Particles */}
        <div className="absolute inset-0 pointer-events-none">
          {particles.map(particle => (
            <div
              key={particle.id}
              className="absolute rounded-full"
              style={{
                left: particle.x + 16, // Offset for padding
                top: particle.y + 16,
                width: particle.size,
                height: particle.size,
                backgroundColor: particle.color,
                opacity: particle.life,
                transform: 'translate(-50%, -50%)'
              }}
            />
          ))}
        </div>

        {/* Group preview */}
        {selectedGroup.length >= MIN_GROUP && (
          <div className="absolute -bottom-12 left-1/2 transform -translate-x-1/2">
            <div className="bg-black/80 text-white px-4 py-2 rounded-full text-sm font-bold">
              Pop {selectedGroup.length} bubbles
            </div>
          </div>
        )}
      </div>

      {/* Minimal instructions */}
      <div className="mt-8 text-gray-400 text-sm text-center max-w-md">
        Click groups of {MIN_GROUP}+ same colors • Bigger groups = more points • Chain combos for massive scores
      </div>
    </div>
  );
}
